<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LEGO 5-Blokjes – Digitale Bouwer</title>
  <style>
    :root {
      --bg: #0b0f14; --panel:#0f172a; --muted:#94a3b8; --text:#e2e8f0; --accent:#22c55e; --accent2:#3b82f6; --danger:#ef4444;
      --grid:#1f2937; --stud:#111827; --shadow:0 10px 28px rgba(0,0,0,.35); --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:radial-gradient(1000px 700px at 20% 0%, #0d1420 0%, #0b0f14 40%, #0a0d12 100%); color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .app{max-width:1100px;margin:0 auto;padding:20px;display:grid;gap:12px}
    .title{font-weight:900; font-size:clamp(22px,4vw,34px)}
    .subtitle{color:var(--muted)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0)); border:1px solid rgba(255,255,255,.08); border-radius:var(--radius); box-shadow:var(--shadow); padding:14px}

    .left-right{display:grid; gap:12px}
    @media (min-width:980px){ .left-right{grid-template-columns: 320px 1fr;} }

    .btn{cursor:pointer;border:0;border-radius:12px;padding:10px 12px;font-weight:800;color:white; box-shadow:var(--shadow);}
    .btn:active{transform:translateY(1px) scale(.99)}
    .btn-ghost{background:rgba(255,255,255,.06); color:var(--text); border:1px solid rgba(255,255,255,.08)}
    .btn-accent{background:linear-gradient(135deg,var(--accent),#16a34a)}
    .btn-primary{background:linear-gradient(135deg,var(--accent2),#2563eb)}
    .btn-danger{background:linear-gradient(135deg,var(--danger),#b91c1c)}

    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);font-weight:700}
    .small{font-size:12px;color:var(--muted)}

    .palette{display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:8px}
    .tool{display:grid;gap:8px}
    .seg{display:grid;gap:8px; background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px}

    label{font-size:12px;color:var(--muted)}
    input[type="number"], select{width:100%; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); color:var(--text); border-radius:10px; padding:8px 10px; outline:none}
    input[type="color"]{ width:100%; height:36px; border:1px solid rgba(255,255,255,.2); border-radius:10px; background:none; padding:0 }

    canvas{width:100%; height:640px; background:linear-gradient(180deg,#0e1624,#0b1220); border:1px solid rgba(255,255,255,.08); border-radius:16px}

    .legend{display:grid;grid-template-columns:repeat(3,auto);gap:6px;align-items:center}
    .legend span{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="app">
    <div class="row" style="justify-content:space-between">
      <div>
        <div class="title">LEGO 5-Blokjes – Digitale Bouwer</div>
        <div class="subtitle">Bouw maximaal <b>5 blokjes</b> op een raster. Draai, verplaats, en wissel laag. Exporteer je model als JSON of PNG.</div>
      </div>
      <div class="row">
        <span class="pill">Blokjes gebruikt: <b id="usedCount">0</b>/5</span>
        <span class="pill">Laag: <b id="layerLabel">0</b></span>
      </div>
    </div>

    <div class="left-right">
      <!-- Tools -->
      <div class="card tool">
        <div class="seg">
          <label>Bloktype</label>
          <div class="palette">
            <button class="btn btn-ghost" data-brick="1x1">1×1</button>
            <button class="btn btn-ghost" data-brick="1x2">1×2</button>
            <button class="btn btn-ghost" data-brick="2x2">2×2</button>
            <button class="btn btn-ghost" data-brick="2x3">2×3</button>
            <button class="btn btn-ghost" data-brick="2x4">2×4</button>
            <button class="btn btn-ghost" data-brick="corner2x2">L‑hoek 2×2</button>
          </div>
        </div>
        <div class="seg">
          <label>Kleur</label>
          <input type="color" id="colorPicker" value="#e11d48" />
          <div class="row">
            <button class="btn btn-ghost quick-color" data-col="#e11d48">Rood</button>
            <button class="btn btn-ghost quick-color" data-col="#f59e0b">Geel</button>
            <button class="btn btn-ghost quick-color" data-col="#22c55e">Groen</button>
            <button class="btn btn-ghost quick-color" data-col="#3b82f6">Blauw</button>
            <button class="btn btn-ghost quick-color" data-col="#6b7280">Grijs</button>
          </div>
        </div>
        <div class="seg">
          <label>Acties</label>
          <div class="row">
            <button class="btn btn-primary" id="placeBtn">Plaats (of klik op raster)</button>
            <button class="btn btn-ghost" id="rotateBtn">Draai (R)</button>
            <button class="btn btn-ghost" id="raiseBtn" title="Laag omhoog">Laag ↑</button>
            <button class="btn btn-ghost" id="lowerBtn" title="Laag omlaag">Laag ↓</button>
          </div>
          <div class="row">
            <button class="btn btn-ghost" id="selectBtn">Selecteer/Verplaats (V)</button>
            <button class="btn btn-danger" id="deleteBtn">Verwijder (Del)</button>
          </div>
        </div>
        <div class="seg">
          <label>Bestand</label>
          <div class="row">
            <button class="btn btn-ghost" id="exportJson">Export JSON</button>
            <button class="btn btn-ghost" id="importJson">Import JSON</button>
            <input type="file" id="fileInput" accept="application/json" style="display:none" />
            <button class="btn btn-ghost" id="exportPng">Export PNG</button>
            <button class="btn btn-ghost" id="resetBtn">Reset</button>
          </div>
          <div class="small">Sneltoetsen: R = draaien, V = selecteren, Del = verwijderen, 0–5 = laag kiezen.</div>
        </div>
      </div>

      <!-- Canvas -->
      <div class="card">
        <canvas id="board" width="960" height="640" aria-label="bouwraster"></canvas>
        <div class="row legend" style="margin-top:8px">
          <span class="pill">Raster: 16×10 studs · 6 lagen (0–5)</span>
          <span>Links‑klik: plaats/verplaats</span>
          <span>Rechts‑klik: deselecteer</span>
        </div>
      </div>
    </div>

    <div class="card small">Let op: dit is een 2D‑topdown bouwer met <b>lagen</b> (z‑niveau). Geen echte 3D‑fysica. Wil je een 3D‑versie met orbit‑camera, dan kan ik die ook bouwen (met of zonder externe library).</div>
  </div>

<script>
(function(){
  const cvs = document.getElementById('board');
  const ctx = cvs.getContext('2d');

  const GRID_W = 16, GRID_H = 10, STUD = 40; // px per stud
  const MAX_BLOCKS = 5; const MAX_LAYER = 5;

  function $(q){return document.querySelector(q)}
  function on(el,ev,fn){el.addEventListener(ev,fn)}

  // State
  const state = {
    blocks: [], // {id,type,w,h,x,y,rot,color,layer}
    sel: null,
    tool: 'place', // place | select
    brick: '2x4', rot: 0, color: '#e11d48', layer: 0
  };

  // Brick library (stud sizes before rotation)
  const BRICKS = {
    '1x1': {w:1,h:1}, '1x2': {w:1,h:2}, '2x2': {w:2,h:2}, '2x3': {w:2,h:3}, '2x4': {w:2,h:4},
    'corner2x2': {w:2,h:2, mask: [[1,1],[1,0]] } // L‑vorm (mask in rot0)
  };

  // Helpers
  const inBounds = (x,y)=> x>=0 && y>=0 && x<GRID_W && y<GRID_H;
  const toGrid = (px,py)=> ({gx: Math.floor(px/STUD), gy: Math.floor(py/STUD)});

  function dims(type, rot){
    const b = BRICKS[type];
    if(!b) return {w:1,h:1};
    if(type==='corner2x2'){ // mask rotates
      return {w:2, h:2};
    }
    return rot%2===0 ? {w:b.w, h:b.h} : {w:b.h, h:b.w};
  }

  function overlaps(a,b){
    if(a.layer!==b.layer) return false;
    // mask-aware for corner
    const cellsA = cells(a), cellsB = cells(b);
    for(const ca of cellsA){ for(const cb of cellsB){ if(ca.x===cb.x && ca.y===cb.y) return true; } }
    return false;
  }

  function cells(bl){
    const list = [];
    if(bl.type==='corner2x2'){
      // base mask rot=0: [[1,1],[1,0]] where [x][y]
      const masks = [
        [[1,1],[1,0]], // rot0
        [[1,1],[0,1]], // rot1
        [[0,1],[1,1]], // rot2
        [[1,0],[1,1]], // rot3
      ];
      const m = masks[bl.rot%4];
      for(let dx=0; dx<2; dx++) for(let dy=0; dy<2; dy++) if(m[dx][dy]) list.push({x:bl.x+dx,y:bl.y+dy,layer:bl.layer});
      return list;
    }
    const d = dims(bl.type, bl.rot);
    for(let dx=0; dx<d.w; dx++) for(let dy=0; dy<d.h; dy++) list.push({x:bl.x+dx,y:bl.y+dy,layer:bl.layer});
    return list;
  }

  function placeAt(gx,gy){
    const d = dims(state.brick, state.rot);
    if(state.blocks.length>=MAX_BLOCKS){ alert('Maximaal 5 blokjes geplaatst. Verwijder er eerst één.'); return; }
    if(!inBounds(gx,gy) || !inBounds(gx+d.w-1, gy+d.h-1)) return;
    const newb = { id: crypto.randomUUID(), type: state.brick, x:gx, y:gy, rot: state.rot%4, color: state.color, layer: state.layer };
    // collision
    for(const b of state.blocks){ if(overlaps(newb,b)) return; }
    state.blocks.push(newb); state.sel = newb.id; draw(); updateUsed();
  }

  function blockAt(gx,gy, layer = state.layer){
    // search top-most same layer first
    for(let i=state.blocks.length-1;i>=0;i--){ const b=state.blocks[i]; if(b.layer!==layer) continue; if(cells(b).some(c=>c.x===gx && c.y===gy)) return b; }
    // allow selecting other layer if none
    for(let i=state.blocks.length-1;i>=0;i--){ const b=state.blocks[i]; if(cells(b).some(c=>c.x===gx && c.y===gy)) return b; }
    return null;
  }

  function moveBlock(b,gx,gy){
    if(!b) return; const d = dims(b.type, b.rot);
    if(!inBounds(gx,gy) || !inBounds(gx+d.w-1, gy+d.h-1)) return false;
    const old = {x:b.x, y:b.y, layer:b.layer};
    b.x=gx; b.y=gy;
    for(const other of state.blocks){ if(other.id!==b.id && overlaps(b,other)){ b.x=old.x; b.y=old.y; return false; } }
    return true;
  }

  function rotateBlock(b){ if(!b) return; const r=(b.rot+1)%4; const old={x:b.x,y:b.y,rot:b.rot}; b.rot=r; if(!moveBlock(b,b.x,b.y)){ b.rot=old.rot; } }

  function setLayer(n){ state.layer = Math.max(0, Math.min(MAX_LAYER, n)); $('#layerLabel').textContent = state.layer; draw(); }

  function removeSelected(){ if(!state.sel) return; const i = state.blocks.findIndex(b=>b.id===state.sel); if(i>=0){ state.blocks.splice(i,1); state.sel=null; draw(); updateUsed(); } }

  function updateUsed(){ $('#usedCount').textContent = state.blocks.length; }

  // Rendering
  function draw(){
    ctx.clearRect(0,0,cvs.width,cvs.height);
    // grid
    ctx.fillStyle = '#0a0f18'; ctx.fillRect(0,0,cvs.width,cvs.height);
    for(let x=0;x<=GRID_W;x++){ ctx.fillStyle= 'rgba(255,255,255,.06)'; ctx.fillRect(x*STUD,0,1,cvs.height); }
    for(let y=0;y<=GRID_H;y++){ ctx.fillStyle= 'rgba(255,255,255,.06)'; ctx.fillRect(0,y*STUD,cvs.width,1); }

    // Helps: render shadows per higher layer as offset
    const layerOffset = (l)=> ({ox: l*2, oy: -l*3});

    // Draw blocks by layer asc
    const sorted = [...state.blocks].sort((a,b)=> a.layer-b.layer);
    for(const b of sorted){
      const off = layerOffset(b.layer);
      const studs = cells(b);
      // body
      ctx.save();
      ctx.translate(off.ox, off.oy);
      // base rect
      const d = dims(b.type, b.rot);
      const x = b.x*STUD, y=b.y*STUD, w=d.w*STUD, h=d.h*STUD;
      // body
      ctx.fillStyle = b.color;
      ctx.fillRect(x+2,y+2,w-4,h-4);
      // top shine
      const g = ctx.createLinearGradient(x,y,x,y+h);
      g.addColorStop(0,'rgba(255,255,255,.25)'); g.addColorStop(1,'rgba(0,0,0,.15)');
      ctx.fillStyle=g; ctx.fillRect(x+2,y+2,w-4,Math.max(0,h-4));
      // studs (dimples)
      for(const c of studs){
        const cx = c.x*STUD + STUD/2; const cy = c.y*STUD + STUD/2;
        ctx.beginPath(); ctx.arc(cx,cy,STUD*0.16,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fill();
        ctx.beginPath(); ctx.arc(cx-2,cy-2,STUD*0.12,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,.25)'; ctx.fill();
      }
      // outline
      ctx.strokeStyle = 'rgba(0,0,0,.6)'; ctx.lineWidth=2; ctx.strokeRect(x+1,y+1,w-2,h-2);

      // selection
      if(b.id===state.sel){ ctx.strokeStyle = '#facc15'; ctx.lineWidth=3; ctx.strokeRect(x+1,y+1,w-2,h-2); }
      ctx.restore();
    }

    // active layer highlight
    ctx.fillStyle='rgba(59,130,246,.08)';
    ctx.fillRect(0, state.layer*0, 0, 0); // placeholder for future per-layer shading

    // ghost preview for placement
    if(state.tool==='place'){
      if(mouse.in){
        const d = dims(state.brick, state.rot);
        const gx = Math.min(GRID_W-d.w, Math.max(0, mouse.gx));
        const gy = Math.min(GRID_H-d.h, Math.max(0, mouse.gy));
        const x = gx*STUD, y=gy*STUD; const w=d.w*STUD, h=d.h*STUD;
        ctx.save(); const off = {ox: state.layer*2, oy:-state.layer*3}; ctx.translate(off.ox, off.oy);
        ctx.fillStyle = hexToRgba(state.color, 0.35); ctx.fillRect(x+2,y+2,w-4,h-4);
        ctx.strokeStyle = hexToRgba('#ffffff', 0.4); ctx.lineWidth=2; ctx.strokeRect(x+2,y+2,w-4,h-4);
        ctx.restore();
      }
    }
  }

  function hexToRgba(hex,a){
    const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex); if(!m) return `rgba(255,255,255,${a})`;
    const r=parseInt(m[1],16), g=parseInt(m[2],16), b=parseInt(m[3],16); return `rgba(${r},${g},${b},${a})`;
  }

  // Mouse / interaction
  const mouse = {x:0,y:0,gx:0,gy:0,in:false, dragging:false, dragOffset:{dx:0,dy:0}};
  on(cvs,'mousemove', (e)=>{ const r=cvs.getBoundingClientRect(); mouse.x=e.clientX-r.left; mouse.y=e.clientY-r.top; const g=toGrid(mouse.x,mouse.y); mouse.gx=g.gx; mouse.gy=g.gy; mouse.in=true; draw(); });
  on(cvs,'mouseleave', ()=>{ mouse.in=false; draw();});

  on(cvs,'contextmenu', (e)=>{ e.preventDefault(); state.sel=null; draw(); });

  on(cvs,'mousedown', (e)=>{
    const g = toGrid(mouse.x, mouse.y);
    if(state.tool==='place'){
      placeAt(g.gx, g.gy);
    } else {
      const b = blockAt(g.gx, g.gy);
      if(b){ state.sel=b.id; const d = dims(b.type,b.rot); mouse.dragging=true; mouse.dragOffset={dx:g.gx-b.x, dy:g.gy-b.y}; draw(); }
    }
  });

  on(cvs,'mouseup', ()=>{ mouse.dragging=false; });
  on(cvs,'mousemove', ()=>{
    if(mouse.dragging && state.tool==='select' && state.sel){ const b = state.blocks.find(x=>x.id===state.sel); if(!b) return; const g=toGrid(mouse.x,mouse.y); moveBlock(b, g.gx-mouse.dragOffset.dx, g.gy-mouse.dragOffset.dy); draw(); }
  });

  // UI controls
  document.querySelectorAll('[data-brick]').forEach(btn=> on(btn,'click',()=>{ state.brick = btn.dataset.brick; document.querySelectorAll('[data-brick]').forEach(b=>b.classList.remove('btn-accent')); btn.classList.add('btn-accent'); }));
  on($('#rotateBtn'),'click',()=>{ if(state.tool==='select' && state.sel){ rotateBlock(state.blocks.find(b=>b.id===state.sel)); } else { state.rot=(state.rot+1)%4; } draw(); });
  on($('#placeBtn'),'click',()=> state.tool='place');
  on($('#selectBtn'),'click',()=> state.tool='select');
  on($('#raiseBtn'),'click',()=> setLayer(state.layer+1));
  on($('#lowerBtn'),'click',()=> setLayer(state.layer-1));
  on($('#deleteBtn'),'click',()=> removeSelected());
  on($('#resetBtn'),'click',()=>{ if(confirm('Alles wissen?')){ state.blocks=[]; state.sel=null; updateUsed(); draw(); } });

  document.querySelectorAll('.quick-color').forEach(b=> on(b,'click',()=>{ state.color=b.dataset.col; $('#colorPicker').value = rgbToHex(state.color); }));
  on($('#colorPicker'),'input', (e)=> state.color = e.target.value);

  function rgbToHex(c){ return c; }

  // Import/Export
  on($('#exportJson'),'click',()=>{
    const data = { version:1, grid:[GRID_W,GRID_H], blocks: state.blocks };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='lego5_model.json'; a.click(); URL.revokeObjectURL(url);
  });
  on($('#importJson'),'click',()=> $('#fileInput').click());
  on($('#fileInput'),'change',(e)=>{
    const f=e.target.files?.[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ try{ const d=JSON.parse(r.result); if(!d.blocks) throw new Error('geen blocks'); state.blocks = d.blocks.slice(0,MAX_BLOCKS); state.sel=null; updateUsed(); draw(); }catch(err){ alert('Kon JSON niet lezen.'); } }; r.readAsText(f);
  });

  on($('#exportPng'),'click',()=>{
    // quick export (what you see)
    const link = document.createElement('a'); link.href = cvs.toDataURL('image/png'); link.download='lego5_model.png'; link.click();
  });

  // Keys
  on(window,'keydown',(e)=>{
    if(['INPUT','SELECT'].includes(document.activeElement.tagName)) return;
    if(e.key==='r' || e.key==='R'){ e.preventDefault(); $('#rotateBtn').click(); }
    if(e.key==='v' || e.key==='V'){ e.preventDefault(); $('#selectBtn').click(); }
    if(e.key==='Delete' || e.key==='Backspace'){ e.preventDefault(); $('#deleteBtn').click(); }
    if(/^[0-5]$/.test(e.key)){ setLayer(parseInt(e.key,10)); }
  });

  // Init
  setLayer(0); updateUsed(); draw();
})();
</script>
</body>
</html>
